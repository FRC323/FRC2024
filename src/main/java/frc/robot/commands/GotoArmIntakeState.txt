package frc.robot.commands;

import edu.wpi.first.wpilibj2.command.Command;
import frc.robot.Constants.Arm;
import frc.robot.Constants.Intake;
import frc.robot.subsystems.ArmSubsystem;
import frc.robot.subsystems.IntakeSubsystem;

public class GotoArmIntakeState extends Command{
    private ArmSubsystem armSubsystem;
    private IntakeSubsystem intakeSubsystem;

    private double armTarget;
    private double intakeTarget;

    private enum SystemState{
        ARM_DOWN_INTAKE_IN,
        ARM_DOWN_INTAKE_OUT,
        ARM_DOWN_INTAKE_INTEFERE,
        ARM_UP_INTAKE_IN,
        ARM_UP_INTAKE_OUT,
        ARM_UP_INTAKE_INTERFERE,
        INVALID_STATE
    }

    private SystemState currentState;
    private SystemState targetState;

    public GotoArmIntakeState(ArmSubsystem armSubsystem, IntakeSubsystem intakeSubsystem, double armTarget, double intakeTarget){
        this.armSubsystem = armSubsystem;
        this.intakeSubsystem = intakeSubsystem;
        this.armTarget = armTarget;
        this.intakeTarget = intakeTarget;

        targetState = getStateFromAngles(armTarget, intakeTarget);

        addRequirements(armSubsystem,intakeSubsystem);
    }

    @Override
    public void execute(){
        if( //Move Arm if intake not in the way
            intakeSubsystem.getWristAngleRads() > Intake.END_DANGER_ZONE
            || intakeSubsystem.getWristAngleRads() < Intake.START_DANGER_ZONE
        ){
            armSubsystem.setTargetRads(armTarget);
        }

        if( //Move intake if arm not in the way
            armSubsystem.getArmAngleRads() < Arm.ARM_INTAKE_UNFOLDING_POSE
        ){
            intakeSubsystem.setTargetRads(intakeTarget);
        }

    }

    @Override
    public boolean isFinished(){
        return false;
        //Todo:
    }

    public SystemState getStateFromAngles(double armAngle, double intakeAngle){
        //Error State
        if(
            intakeAngle > Intake.SOFT_LIMIT_MAX
            || intakeAngle < Intake.SOFT_LIMIT_MIN
            || armAngle < Arm.SOFT_LIMIT_MAX
            || armAngle > Arm.SOFT_LIMIT_MIN
        ) return SystemState.INVALID_STATE;

        
        if(armAngle > Arm.ARM_INTAKE_UNFOLDING_POSE){
            if(intakeAngle < Intake.START_DANGER_ZONE) return SystemState.ARM_DOWN_INTAKE_IN;
            if(intakeAngle > Intake.END_DANGER_ZONE) return SystemState.ARM_DOWN_INTAKE_OUT;
            return SystemState.ARM_DOWN_INTAKE_INTEFERE;
        }else{
            if(intakeAngle < Intake.START_DANGER_ZONE) return SystemState.ARM_UP_INTAKE_IN;
            if(intakeAngle > Intake.END_DANGER_ZONE) return SystemState.ARM_UP_INTAKE_OUT;
            return SystemState.ARM_UP_INTAKE_INTERFERE;
        }
    }


}
